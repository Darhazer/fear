module Fear
  module Extractor
    # This module contains AST nodes for GrammarParser
    # generated by +treetop+. The sole purpose of them all is to
    # generate matchers
    module Grammar
      class Node < Treetop::Runtime::SyntaxNode
      end

      class ArrayLiteral < Node
        def to_matcher
          list = elements.slice(1...-1).reject(&:empty?)
          if list.empty?
            EmptyListMatcher.new(
              index: 0,
              node: self,
            )
          else
            list.first.to_matcher
          end
        end
      end

      class Array < Node
        def to_matcher
          head, tail = elements.reject(&:empty?)
          ArrayMatcher.new(
            head: head.to_matcher(0),
            tail: tail ? tail.to_matcher(1) : EmptyListMatcher.new(index: 1, node: self),
            index: 0,
            node: self,
          )
        end
      end

      class ArrayTail < Node
        def to_matcher(index)
          head, tail = elements[1].elements
          ArrayMatcher.new(
            head: head.to_matcher(index),
            tail: tail.empty? ? EmptyListMatcher.new(index: 1, node: self) : tail.to_matcher(1),
            index: index,
            node: self,
          )
        end
      end

      class ArrayTailSplat < Node
        def to_matcher(index)
          splat, = elements[1]
          ArrayMatcher.new(
            head: splat.to_matcher,
            tail: EmptyListMatcher.new(index: index + 1, node: self),
            index: index,
            node: self,
          )
        end
      end

      class ArrayHead < Node
        def to_matcher(index)
          ArrayHeadMatcher.new(
            element: elements[1].to_matcher,
            index: index,
            node: self,
          )
        end
      end

      class ArraySplat < Node
        def to_matcher
          elements[1].to_matcher
        end
      end

      class AnonymousArraySplat < Node
        def to_matcher
          AnonymousArraySplatMatcher.new(node: self)
        end
      end

      class FloatLiteral < Node
        def to_matcher
          NumberMatcher.new(value: value, node: self)
        end

        def value
          text_value.to_f
        end
      end

      class IntegerLiteral < Node
        def to_matcher
          NumberMatcher.new(value: value, node: self)
        end

        def value
          text_value.to_i
        end
      end

      class StringLiteral < Node
        def to_matcher
          StringMatcher.new(value: value, node: self)
        end

        def value
          elements[1].text_value
        end
      end

      require 'yaml'

      class DoubleQuotedStringLiteral < StringLiteral
        def to_matcher
          StringMatcher.new(value: value, node: self)
        end

        def value
          YAML.safe_load(%(---\n"#{super}"\n))
        end
      end

      class TrueLiteral < Node
        def to_matcher
          BooleanMatcher.new(value: true, node: self)
        end
      end

      class FalseLiteral < Node
        def to_matcher
          BooleanMatcher.new(value: false, node: self)
        end
      end

      class NilLiteral < Node
        def to_matcher
          NilMatcher.new(node: self)
        end
      end

      class AnyIdentifier < Node
        def to_matcher
          AnyMatcher.new(node: self)
        end
      end

      class Identifier < Node
        def to_matcher
          IdentifierMatcher.new(name: text_value.to_sym, node: self)
        end
      end

      class NamedArraySplat < Node
        def to_matcher
          NamedArraySplatMatcher.new(name: name, node: self)
        end

        def name
          text_value[1..-1].to_sym
        end
      end

      class TypeLiteral < Node
        def to_matcher
          TypeMatcher.new(class_name: text_value, node: self)
        end
      end

      class TypedIdentifier < Node
        def to_matcher
          identifier, type = elements.values_at(0, 2)
          TypedIdentifierMatcher.new(
            identifier: identifier.to_matcher,
            type: type.to_matcher,
            node: type,
          )
        end
      end

      class IdentifiedMatcher < Node
        def to_matcher
          identifier, matcher = elements.values_at(0, -1)
          Extractor::IdentifiedMatcher.new(
            identifier: identifier.to_matcher,
            matcher: matcher.to_matcher,
            node: matcher,
          )
        end
      end

      class ExtractorLiteral < Node
        def to_matcher
          extractor = elements[0]
          arguments = elements[2].empty? ? EmptyListMatcher.new(node: self, index: 0) : elements[2].to_matcher

          ExtractorMatcher.new(
            name: extractor.text_value,
            arguments_matcher: arguments,
            node: self,
          )
        end
      end
    end
  end
end
